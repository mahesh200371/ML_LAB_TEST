# -*- coding: utf-8 -*-
"""final_lab_test_02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Fx9kbX-FJ_2F0jK8DncRt6QCkhSqpneG
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.metrics import roc_auc_score, roc_curve, auc

from google.colab import drive
drive.mount('/content/drive')
df = pd.read_csv("/content/drive/MyDrive/SKILLS_LAB/loan_data.csv")
X = df.drop(columns=['id', 'loan_paid_back'])
y = df['loan_paid_back']



numerical_cols = ['annual_income', 'debt_to_income_ratio', 'credit_score',
                  'loan_amount', 'interest_rate']
categorical_cols = ['gender', 'marital_status', 'education_level',
                    'employment_status', 'loan_purpose', 'grade_subgrade']

# Numerical: impute + scale
num_pipe = Pipeline([
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])

# Categorical: impute + one-hot encode
cat_pipe = Pipeline([
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=False))
])

preprocessor = ColumnTransformer([
    ('num', num_pipe, numerical_cols),
    ('cat', cat_pipe, categorical_cols)
])

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42
)

rf_model = RandomForestClassifier(
    n_estimators=300,
    max_depth=10,
    min_samples_split=10,
    min_samples_leaf=5,
    class_weight='balanced',  # handles class imbalance
    random_state=42,
    n_jobs=-1
)

pipeline = Pipeline([
    ('preprocessor', preprocessor),
    ('classifier', rf_model)
])

pipeline.fit(X_train, y_train)

y_proba = pipeline.predict_proba(X_test)[:, 1]
test_auc = roc_auc_score(y_test, y_proba)
print(f"Test AUC: {test_auc:.4f}")

# Plot ROC
fpr, tpr, _ = roc_curve(y_test, y_proba)
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, label=f'Random Forest (AUC = {test_auc:.4f})', color='forestgreen', lw=2)
plt.plot([0, 1], [0, 1], 'k--', label='Random (AUC = 0.5)', lw=1)
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve â€“ Random Forest Loan Default Prediction')
plt.legend()
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()

# Prepare test set with predictions
test_df = X_test.copy()
test_df['y_true'] = y_test.values
test_df['y_proba'] = y_proba
test_df = test_df.reset_index(drop=True)

purpose_auc = {}
for purpose in test_df['loan_purpose'].dropna().unique():
    subset = test_df[test_df['loan_purpose'] == purpose]
    if len(subset['y_true'].unique()) >= 2:
        auc_val = roc_auc_score(subset['y_true'], subset['y_proba'])
        purpose_auc[purpose] = (auc_val, len(subset))

sorted_purposes = sorted(purpose_auc.items(), key=lambda x: x[1][0])

print("\nTop 3 loan purposes (by AUC):")
for p, (auc_val, n) in sorted_purposes[-3:][::-1]:
    print(f"  {p}: AUC = {auc_val:.4f} (n={n})")

print("\nBottom 3 loan purposes (by AUC):")
for p, (auc_val, n) in sorted_purposes[:3]:
    print(f"  {p}: AUC = {auc_val:.4f} (n={n})")